# !/usr/bin/env python

# import time
import rospy

# import tf
# from rospy import ServiceProxy, ServiceException
#
# from std_msgs.msg import String
from geometry_msgs.msg import Pose, PoseStamped
from nav_msgs.msg import Path
from sensor_msgs.msg import JointState
# from geometry_msgs.msg import PoseStamped
from nav_msgs.srv import GetPlan
#
# from ros_utilities import *

# Blocks generated by launch file
# PandaController node calls Vision node to interpret workspace (service call?)
# Vision node returns a list of XYZ(?) block locations as a GetPlan message on 'panda_waypoints' topic
# PandaController interprets this list, adds a midpoint and destination pose, and then sends this list of
#    desired EE positions to the Trajectory node
# Trajectory node then sends a long list of joint position/velocity/effort for each joint that together detail each
#    intermediate time step of the robot's animation
# PandaController publishes these as JointState messages, which will be picked up by the robot_state_publisher and
#    will animate our model <<<TODO: send messages directly from trajectory node instead? more efficient?

# TODO: arbitrary; figure out how we want to sort: put each color in a pre-specified area of the workspace?
# TODO: prepare list of block locations by adding an extra waypoint to lift the block up some Z levels before
#  moving to side
# TODO: figure out how we want to communicate the color of each block:
    # > have different topics for each color?
    # > use a ROS message type where we can add IDs?

# TODO: all of our XYZ coordinates are in the 'base frame' reference. What should we use for frame_id? (in ros messages)


class PandaController:

    def __init__(self):
        self.joint_update_delay = 10  # sleep time in ms between sending new joint position

        self.current_joints = [0, 0, 0, 0, 0, 0, 0]

        rospy.init_node("panda_control")
        self.joint_state_pub = rospy.Publisher("/joint_states", JointState)
        self.waypoint_pub = rospy.Publisher("/panda_waypoints", GetPlan)
        rospy.Subscriber('/block_locations', GetPlan, self.request_trajectory)

        # TODO: start vision node
        # TODO: start trajectory node

        rospy.sleep(10)
        rospy.spin()
        rospy.loginfo("PandaController server node ready.")

    ### moved to matlab files ###
    # def joints_update(self, joints_pos, joints_vel, joints_eff):
    #     # compose JointState message with position, velocity and effort/force for each joint
    #     # joints are denoted by name as defined in the xacro
    #     name = ['panda_joint1', 'panda_joint2', 'panda_joint3', 'panda_joint4',
    #             'panda_joint5', 'panda_joint6', 'panda_joint7']
    #     position = []
    #     velocity = []
    #     effort = []
    #     for i in range(len(joints_pos)):
    #         position.append(joints_pos[i])
    #         velocity.append(joints_vel[i])
    #         effort.append(joints_eff[i])
    #     j_msg = JointState().name = name
    #     j_msg.position = position
    #     j_msg.velocity = velocity
    #     j_msg.effort = effort
    #     self.joint_state_pub.publish(j_msg)
    #     return

    def go_to(self, trajectory):
        # takes a trajectory, which is an array of JointState values (pos, vel, effort)
        # iterate through each trajectory point and set each joint variable
        for i in range(len(trajectory)):
            self.joints_update(trajectory[0][i], trajectory[1][i], trajectory[2][i])
            rospy.sleep(self.joint_update_delay)

    @staticmethod
    def request_trajectory(msg):
        # send message to trajectory node with start, midpoint and end location in XYZ
        # prepare '/block_locations' message for trajectory: add midpoint and goal location based on color of block
        waypoints = []
        for i in range(len(msg.poses)):
            # block location
            xi = msg.poses[2*i].position.x
            yi = msg.poses[2*i].position.y
            zi = msg.poses[2*i].position.z
            waypoints.append([xi, yi, zi])
            # midpoint; just lifts 100 z units TODO: tweak this
            zm = zi + 100
            waypoints.append([xi, yi, zm])
            # destination location TODO: see above, how to differentiate block types?
            # currently assumes it's done by the vision node and that node sends:
            # ['block1 location','destination','block2 location',... etc]
            xf = msg.poses[2*i+1].position.x
            yf = msg.poses[2*i+1].position.y
            zf = msg.poses[2*i+1].position.z
            waypoints.append([xf, yf, zf])

        # prepare Path message
        path_msg = Path()
        for i in range(len(waypoints)):
            pt = PoseStamped()
            pt.pose.position.x = waypoints[i][0]
            pt.pose.position.y = waypoints[i][1]
            pt.pose.position.z = waypoints[i][2]
            path_msg.poses.append(pt)
        return


if __name__ == '__main__':
    panda = PandaController()