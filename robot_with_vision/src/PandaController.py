#!/usr/bin/env python
import sys

import rospy
from geometry_msgs.msg import Pose, PoseArray
from nav_msgs.msg import Path
from sensor_msgs.msg import JointState
from nav_msgs.srv import GetPlan
from robot_with_vision.msg import centers, points_to_go_to


# PandaController coordinator node: uses custom ROS message to receive a list of block locations and their respective
# colors, then publishes a Path on the /block_points topic, which the Matlab portion uses to calculate required
# kinematics and dynamics, and publishes these results as JointState messages on /joint_states

# Blocks generated by launch file
# PandaController node subscribes to /block_points and waits for Vision node to interpret workspace
# Vision node returns a list of XYZ(?) block locations as a custom message on 'block_points' topic
# PandaController interprets this list, adds a midpoint and destination pose, and then sends this list of
#    desired EE positions to the Trajectory node
# Trajectory node then calculates a long list of joint position/velocity/effort for each joint that together detail each
#    intermediate time step of the robot's movements
# Trajectory node publishes these as JointState messages, which will be picked up by the robot_state_publisher and
#    will animate our virtual model


class PandaController:

    def __init__(self):
        self.joint_update_delay = 10  # sleep time in ms between sending new joint position

        self.joint_state_pub = rospy.Publisher("/joint_states", JointState, queue_size=10)
        self.waypoint_pub = rospy.Publisher("/panda_waypoints", PoseArray, queue_size=10)
        rospy.Subscriber('/block_points', points_to_go_to, self.request_trajectory)

        rospy.loginfo("PandaController server node ready.")

    def request_trajectory(self, msg):
        # send message to trajectory node with start, midpoint and end location in XYZ
        # prepare '/panda_waypoints' message for trajectory: add midpoint and goal location based on color of block
        # rospy.logwarn(msg)
        blue = Pose()
        blue.position.x = .5
        blue.position.y = .5
        blue.position.z = .1
        red = Pose()
        red.position.x = .5
        red.position.y = .6
        red.position.z = .1
        green = Pose()
        green.position.x = .5
        green.position.y = .7
        green.position.z = .1
        # prepare Path message
        posearray_msg = PoseArray()
        waypoints = []

        for i in range(len(msg.colors)):
            # block location
            pt_block = Pose()
            pt_block.position.x = float(msg.x_points[i])
            pt_block.position.y = float(msg.y_points[i])
            pt_block.position.z = float(msg.z_points[i])
            waypoints.append(pt_block)
            # midpoint; just lifts .2m in z axis
            pt_mid = Pose()
            pt_mid.position.x = float(msg.x_points[i])
            pt_mid.position.y = float(msg.y_points[i])
            pt_mid.position.z = float(msg.z_points[i]) + .2
            waypoints.append(pt_mid)
            # sorted destination location
            if msg.colors[i] == 'blue':
                waypoints.append(blue)
            if msg.colors[i] == 'red':
                waypoints.append(red)
            if msg.colors[i] == 'green':
                waypoints.append(green)

        posearray_msg.poses = waypoints
        self.waypoint_pub.publish(posearray_msg)
        rospy.sleep(3)
        return


def main(args):
    panda = PandaController()
    rospy.init_node('PandaController', anonymous=True)
    try:
        rospy.spin()
    except KeyboardInterrupt:
        print("Shutting down")


if __name__ == '__main__':
    main(sys.argv)
